
//@file $name$ interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

$-[class]$$[iface]$
#include "$relpath$"
$-[/iface]$$[/class]$
#include "$hdr$"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>


static_assert(intergen_interface::VERSION == $version$, "interface must be rebuilt with a different intergen version");

using namespace coid;

$-[class iface.empty!]$
static_assert( std::is_base_of<policy_intrusive_base, $nss rest="::" after="::"$$class$>::value, "class '$class$' must be derived from policy_intrusive_base");
static_assert( std::is_base_of<policy_intrusive_base, $nss rest="::" after="::"$$class$>::value, "class '$class$' must be derived from policy_intrusive_base");

$-[iface]$
////////////////////////////////////////////////////////////////////////////////
// interface $name$ of class $..class$
$[ns]$
namespace $@value$ {
$-[/ns]$

///
class $name$_dispatcher : public $name$
{
private:

    static coid::binstring* _capture;
    static uint16 _instid;
    static ifn_t* _vtable1;
    static ifn_t* _vtable2;

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[$nifcmethods$];
$-[method !static?]$
 $-(if hasifc?)$
        _vtable1[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$size$$[/args]$)$(if const?)$const$(/if)$>(&$name$__ifc_wrapper));
 $-(elif)$
        _vtable1[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$size$$[/args]$)$(if const?)$const$(/if)$>(&$....ns$::$....class$::$intname$));
 $-(/if)$
$-[/method]-$

        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))

$-[method capture?]$

    $return.type$ __capture__$(if operator?)$operator$(elif)$$name$$index$$(/if)$($[args rest=", "]$$type$ $name$$[/args]$)$(if const?)$ const$(/if)$
    {
        (*_capture) << uint16(_instid | $index$) $-[args inarg?]$ << $name$$[/args]$;
        return VT_CALL2($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
    }
$-[/method]$

$-[method hasifc?]$
    $return.type$ $name$__ifc_wrapper($[args rest=", "]$$type$ $name$$[/args]$)$(if const?)$ const$(/if)$
    {
        iref<$return.ifc$> __ret__ = $name$($[args rest=","]$$name$$[/args]$);
        if (!__ret__)
            return 0;

        typedef iref<$return.ifc$> (*fn_wrap)(policy_intrusive_base*, intergen_interface*);
        static fn_wrap wrapper = reinterpret_cast<fn_wrap>(
            coid::interface_register::get_interface_creator("$ns rest="::" after="::"$$name$@wrapper"));

        return wrapper ? wrapper(__ret__.get(), new $..name$_dispatcher) : 0;
    }
$[/method]-$

    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[$nifcmethods$];
$-[method !static?]$
    $-(if capture? operator?)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&__capture__operator));
    $-(elif capture?)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&__capture__$name$$index$));
    $-(elif)$
        _vtable2[$@order$] = vtable1[$@order$];
    $-(/if)$
$-[/method]-$

        return _vtable2;
    }

protected:

    COIDNEWDELETE("$[ns]$$@value$::$[/ns]$$name$_dispatcher");

    $name$_dispatcher()
    {}

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        switch(mid) {
        $-[method capture? noutargs!]$
        case $index$: {
            $-[args inarg?]$
            $-(if token?)$
            coid::token $name$ = bin.string();
            $-(elif)$
            const $basetype$& $name$ = bin.fetch<$basetype$>();
            $-(/if)$
            $-[/args]$
            VT_CALL($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
            break;
        }
        $-[/method]$
        case UMAX32:
        default: throw coid::exception("unknown method id in $name$ capture dispatcher");
        }
    }
$-(if varname?)$

    ///Cleanup routine called from ~$name$()
    static void _cleaner_callback( $name$* m, intergen_interface* ifc ) {
        $..ns default=" "$::$..class$* host = m->host<$..ns$::$..class$>();
        if (host) host->$varname$ = ifc;
    }
$-(/if)$
$-(if virtual!)$

    static iref<$name$> _generic_interface_creator($..ns default=" "$::$..class$* host, $name$* __here__)
    {
        //cast to dispatch to sidestep protected access restrictions
        $name$_dispatcher* __disp__ = static_cast<$name$_dispatcher*>(__here__);
        if (!__disp__)
            __disp__ = new $name$_dispatcher;

        __disp__->_host.create(host);
        __disp__->_vtable = _capture ? get_vtable_intercept() : get_vtable();

        $--(if varname?)$
        if (!host->$varname$) {
            __disp__->_cleaner = &_cleaner_callback;
            host->$varname$ = __disp__;
        }
        $-(/if)$

        $-(if onconnect?)$
        host->$onconnect$();

        $-(/if)$
        $-(if onconnectev?)$
        __disp__->$onconnectev$();

        $-(/if)$
        return __disp__;
    }
$-(/if)$

public:

    // creator methods

$-[method static?]$
    static iref<$..name$> $name$( $..name$* __here__$[args]$, $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$ )
    {
        iref<$....ns default=" "$::$....class$> __host__ = $....ns$::$....class$::$intname$($[args rest=", "]$$name$$[/args]$);
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

$-[/method]$
    ///Register interface creators in the global registry
    static void register_interfaces( bool on )
    {
$-(if virtual!)$
        interface_register::register_interface_creator(
            "$ns rest="::" after="::"$$name$@wrapper",
            on ? (void*)&_generic_interface_creator : nullptr);

$-(/if)$
$-[method static?]$
        interface_register::register_interface_creator(
            "$..ns rest="::" after="::"$$..name$.$name$@$..hash$",
            on ? (void*)&$name$ : nullptr);
$-[/method]$
    }
};

coid::binstring* $name$_dispatcher::_capture = 0;
uint16 $name$_dispatcher::_instid = 0xffffU;
intergen_interface::ifn_t* $name$_dispatcher::_vtable2 = 0;
intergen_interface::ifn_t* $name$_dispatcher::_vtable1 = 0;


//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&$name$_dispatcher::register_interfaces);

void* force_register_$name$() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&$name$_dispatcher::register_interfaces);
    return autoregger.get();
}

$-[ns]$
} //namespace $@value$
$-[/ns]$

$-(if event?)$
// events

$[..nss]$namespace $@value$ {
$[/..nss]-$

$-[event !implicit?]$
$return.type$ $....class$::$intname$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $name$$size$$[/args]$) $-(if const?)$ const$(/if)$
{
	if (!$..varname$) $(if default_event_body?)${ $default_event_body$ }$(elif)$
        throw coid::exception() << "$name$" << " handler not implemented";$(/if)$
    else
        return $..varname$->iface<$..ns rest="::" after="::"$$..name$>()->$name$($[args rest=", "]$$name$$[/args]$);
}
$[/event]-$

$[..nss]$} //namespace $@value$
$[/..nss]-$
$(/if)-$

$-[/iface]$$[/class]$
